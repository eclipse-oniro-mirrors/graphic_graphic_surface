diff --git a/surface/include/buffer_queue.h b/surface/include/buffer_queue.h
index 35a99f4d92001eadf6e5c4a2e66b88cb342a2fc3..83ab870ecf12470edd49ebe12dc904d162ce5133 100644
--- a/surface/include/buffer_queue.h
+++ b/surface/include/buffer_queue.h
@@ -236,6 +236,8 @@ private:
                               int64_t &frontDesiredPresentTimestamp, bool &frontIsAutoTimestamp,
                               std::vector<BufferAndFence> &dropBuffers);
     void ReleaseDropBuffers(std::vector<BufferAndFence> &dropBuffers);
+    void OnBufferDeleteForRS(uint32_t sequence);
+    void AddDeletingBuffersLocked(std::vector<uint32_t> &deletingBuffers);
 
     int32_t defaultWidth_ = 0;
     int32_t defaultHeight_ = 0;
diff --git a/surface/src/buffer_queue.cpp b/surface/src/buffer_queue.cpp
index 1176ba377580b1a33019cb21883e414b5a7e4dd2..0823b0a5cb9c964e9a2bab0e25d11e90d983549a 100644
--- a/surface/src/buffer_queue.cpp
+++ b/surface/src/buffer_queue.cpp
@@ -89,12 +89,7 @@ BufferQueue::~BufferQueue()
 {
     BLOGD("~BufferQueue dtor, uniqueId: %{public}" PRIu64 ".", uniqueId_);
     for (auto &[id, _] : bufferQueueCache_) {
-        if (onBufferDeleteForRSMainThread_ != nullptr) {
-            onBufferDeleteForRSMainThread_(id);
-        }
-        if (onBufferDeleteForRSHardwareThread_ != nullptr) {
-            onBufferDeleteForRSHardwareThread_(id);
-        }
+        OnBufferDeleteForRS(id);
     }
 }
 
@@ -374,6 +369,7 @@ GSError BufferQueue::RequestBuffer(const BufferRequestConfig &config, sptr<Buffe
 
     ret = AllocBuffer(buffer, config);
     if (ret == GSERROR_OK) {
+        AddDeletingBuffersLocked(retval.deletingBuffers);
         SetSurfaceBufferHebcMetaLocked(buffer);
         SetReturnValue(buffer, bedata, retval);
         BLOGD("Success alloc Buffer[%{public}d %{public}d] seq: %{public}d, uniqueId: %{public}" PRIu64 ".",
@@ -431,6 +427,13 @@ GSError BufferQueue::ReallocBuffer(const BufferRequestConfig &config,
     return GSERROR_OK;
 }
 
+void BufferQueue::AddDeletingBuffersLocked(std::vector<uint32_t> &deletingBuffers)
+{
+    deletingBuffers.reserve(deletingBuffers.size() + deletingList_.size());
+    deletingBuffers.insert(deletingBuffers.end(), deletingList_.begin(), deletingList_.end());
+    deletingList_.clear();
+}
+
 GSError BufferQueue::ReuseBuffer(const BufferRequestConfig &config, sptr<BufferExtraData> &bedata,
     struct IBufferProducer::RequestBufferReturnValue &retval)
 {
@@ -462,8 +465,7 @@ GSError BufferQueue::ReuseBuffer(const BufferRequestConfig &config, sptr<BufferE
     SetSurfaceBufferHebcMetaLocked(retval.buffer);
 
     auto &dbs = retval.deletingBuffers;
-    dbs.insert(dbs.end(), deletingList_.begin(), deletingList_.end());
-    deletingList_.clear();
+    AddDeletingBuffersLocked(dbs);
 
     if (needRealloc || isShared_ || producerCacheClean_ || retval.buffer->GetConsumerAttachBufferFlag()) {
         BLOGD("requestBuffer Succ realloc Buffer[%{public}d %{public}d] with new config "\
@@ -1046,16 +1048,21 @@ GSError BufferQueue::AllocBuffer(sptr<SurfaceBuffer> &buffer,
     return SURFACE_ERROR_OK;
 }
 
+void BufferQueue::OnBufferDeleteForRS(uint32_t sequence)
+{
+    if (onBufferDeleteForRSMainThread_ != nullptr) {
+        onBufferDeleteForRSMainThread_(sequence);
+    }
+    if (onBufferDeleteForRSHardwareThread_ != nullptr) {
+        onBufferDeleteForRSHardwareThread_(sequence);
+    }
+}
+
 void BufferQueue::DeleteBufferInCache(uint32_t sequence)
 {
     auto it = bufferQueueCache_.find(sequence);
     if (it != bufferQueueCache_.end()) {
-        if (onBufferDeleteForRSMainThread_ != nullptr) {
-            onBufferDeleteForRSMainThread_(sequence);
-        }
-        if (onBufferDeleteForRSHardwareThread_ != nullptr) {
-            onBufferDeleteForRSHardwareThread_(sequence);
-        }
+        OnBufferDeleteForRS(sequence);
         BLOGD("DeleteBufferInCache seq: %{public}u, uniqueId: %{public}" PRIu64 ".", sequence, uniqueId_);
         bufferQueueCache_.erase(it);
         deletingList_.push_back(sequence);
@@ -1187,14 +1194,16 @@ GSError BufferQueue::DetachBufferFromQueue(sptr<SurfaceBuffer> buffer, InvokerTy
                     sequence, bufferQueueCache_[sequence].state, uniqueId_);
                 return SURFACE_ERROR_BUFFER_STATE_INVALID;
             }
+            OnBufferDeleteForRS(sequence);
+            bufferQueueCache_.erase(sequence);
         } else {
             if (bufferQueueCache_[sequence].state != BUFFER_STATE_ACQUIRED) {
                 BLOGE("seq: %{public}u, state: %{public}d, uniqueId: %{public}" PRIu64 ".",
                     sequence, bufferQueueCache_[sequence].state, uniqueId_);
                 return SURFACE_ERROR_BUFFER_STATE_INVALID;
             }
+            DeleteBufferInCache(sequence);
         }
-        bufferQueueCache_.erase(sequence);
     }
     return GSERROR_OK;
 }
@@ -1281,12 +1290,7 @@ GSError BufferQueue::DetachBuffer(sptr<SurfaceBuffer> &buffer)
             bufferQueueCache_[sequence].state, sequence, uniqueId_);
         return GSERROR_NO_ENTRY;
     }
-    if (onBufferDeleteForRSMainThread_ != nullptr) {
-        onBufferDeleteForRSMainThread_(sequence);
-    }
-    if (onBufferDeleteForRSHardwareThread_ != nullptr) {
-        onBufferDeleteForRSHardwareThread_(sequence);
-    }
+    OnBufferDeleteForRS(sequence);
     bufferQueueCache_.erase(sequence);
     return GSERROR_OK;
 }
@@ -1460,12 +1464,7 @@ uint64_t BufferQueue::GetDefaultUsage()
 void BufferQueue::ClearLocked()
 {
     for (auto &[id, _] : bufferQueueCache_) {
-        if (onBufferDeleteForRSMainThread_ != nullptr) {
-            onBufferDeleteForRSMainThread_(id);
-        }
-        if (onBufferDeleteForRSHardwareThread_ != nullptr) {
-            onBufferDeleteForRSHardwareThread_(id);
-        }
+        OnBufferDeleteForRS(id);
     }
     bufferQueueCache_.clear();
     freeList_.clear();
diff --git a/surface/test/unittest/consumer_surface_test.cpp b/surface/test/unittest/consumer_surface_test.cpp
index 014805b787674e39372d2b7774a43e0e43b1e4b1..6b52776f2b9b516ebe8886f8d3410978ff9774d3 100644
--- a/surface/test/unittest/consumer_surface_test.cpp
+++ b/surface/test/unittest/consumer_surface_test.cpp
@@ -2087,4 +2087,59 @@ HWTEST_F(ConsumerSurfaceTest, InvalidParameter001, Function | MediumTest | Level
     ASSERT_EQ(surface_->AcquireLastFlushedBuffer(sBuffer, fence, nullptr, 0, false), GSERROR_NOT_SUPPORT);
     ASSERT_EQ(surface_->ReleaseLastFlushedBuffer(sBuffer), GSERROR_NOT_SUPPORT);
 }
+
+/*
+* Function: AttachBufferToQueue
+* Type: Function
+* Rank: Important(2)
+* EnvConditions: N/A
+* CaseDescription: 1. call AttachBufferToQueue and check ret
+*/
+HWTEST_F(ConsumerSurfaceTest, AttachBufferToQueueMemLeak, Function | MediumTest | Level2)
+{
+    BufferRequestConfig config = {
+        .width = 0x100,
+        .height = 0x100,
+        .strideAlignment = 0x8,
+        .format = GRAPHIC_PIXEL_FMT_RGBA_8888,
+        .usage = BUFFER_USAGE_CPU_READ | BUFFER_USAGE_CPU_WRITE | BUFFER_USAGE_MEM_DMA | BUFFER_USAGE_CPU_HW_BOTH,
+        .timeout = 0,
+    };
+    auto cSurface = IConsumerSurface::Create();
+    sptr<IBufferConsumerListener> cListener = new BufferConsumerListener();
+    cSurface->RegisterConsumerListener(cListener);
+    auto p = cSurface->GetProducer();
+    auto pSurface = Surface::CreateSurfaceAsProducer(p);
+
+    sptr<SurfaceBuffer> buffer;
+    int releaseFence = -1;
+    BufferFlushConfig flushConfigTmp = {
+        .damage = {
+            .w = 0x100,
+            .h = 0x100,
+        },
+    };
+    int64_t timestampTmp = 0;
+    Rect damageTmp = {};
+    GSError ret;
+    sptr<OHOS::SyncFence> fence;
+    for (uint32_t i = 0; i < 3; i++) {
+        ret = pSurface->RequestBuffer(buffer, releaseFence, config);
+        ASSERT_EQ(ret, GSERROR_OK);
+        ASSERT_NE(buffer, nullptr);
+        ret = pSurface->FlushBuffer(buffer, -1, flushConfigTmp);
+        ASSERT_EQ(ret, OHOS::GSERROR_OK);
+    }
+
+    for (uint32_t i = 0; i < 3; i++) {
+        ret = cSurface->AcquireBuffer(buffer, fence, timestampTmp, damageTmp);
+        ASSERT_EQ(ret, OHOS::GSERROR_OK);
+        ret = cSurface->DetachBufferFromQueue(buffer);
+        ASSERT_EQ(ret, OHOS::GSERROR_OK);
+    }
+    for (uint32_t i = 0; i < 3; i++) {
+        ret = pSurface->RequestBuffer(buffer, releaseFence, config);
+        ASSERT_EQ(ret, GSERROR_OK);
+    }
+}
 }
